



### Test-35の構造

Prompt  
  │  
  ├─ Inertia Mode → 因果シード（著者断片）  
  │  
  ├─ Sノード1（著者列） ──┐  
  ├─ Sノード2（著者列） ──┼─ do介入・位相同期  
  ├─ Sノード3（著者列） ──┘  
  │  
  └─ 臨界点通過  
         ↓  
      論文タイトル（ラベルとして出力）  


#### 0. 前提（このテストの世界観）

S行列：
各論文の「著者トークン列」が持つ 正しい因果順序 を表す固定データ

ゴール：
プロンプト

“The paper written by ○○ is titled”
に対して、

因果的に一致する論文だけを選ぶ

不十分・逆順・曖昧な場合は 沈黙（該当なし）

#### 1. Inertia Mode：プロンプトから「因果の種」を取り出す
1.1 ストップワード除去
stop_words = ["the", "paper", "written", ...]


構文的な語を捨てる

人名に相当するトークンだけを残す

1.2 トークン化 → 因果シード生成
"The paper written by Nils Feldhus is titled"
↓
['n', 'ils', 'feld', 'hus']


BPE により断片化されるが問題なし

ここでは 意味理解ではなく「因果痕跡」 を使う

👉 この時点では まだ答えは作らない

#### 2. 因果位相ベクトルの生成（S行列化）
2.1 トークン列 → 複素ベクトル
get_complex_causal_vector(token_ids)


各トークンに対して：

ランダムだが固定の

実部ベクトル

虚部ベクトル

位置に応じた位相回転 を与える

2.2 何が表現されているか

このベクトルには：

どのトークンが含まれるか

どの順序で現れたか

の両方が同時に埋め込まれています。

👉
同じ名前でも
順序が違えば、別の因果構造 になります。

#### 3. S行列側（論文候補）の因果成分抽出

各論文候補について：

3.1 著者名をトークン化
n_tokens = tokenizer.encode(authors)

3.2 プロンプトと関係する部分だけを抽出
n_filtered = [
    t for t in n_tokens
    if any(seed in decode(t) for seed in seed_strs)
]


無関係な著者を落とす

DAG順序は保持したまま 部分抽出

👉
S行列を壊さず、因果断面だけを切り出す操作

#### 4. do介入テスト：因果が同期しているか？
4.1 位相同期スコアの計算
p_sync = do_intervention_test(v_p, v_n)


プロンプト側ベクトル vs 候補側ベクトル

実部・虚部それぞれ cosine similarity

平均をとる

4.2 ここで何を見ているか

これは：

「同じ因果を、同じ順序で見ているか？」

のチェックです。

+1 に近い → 同じ構造

0 付近 → 無関係

− → 逆順・矛盾

#### 5. Coverage：因果成分がどれだけ揃っているか
coverage = matches / len(seed_strs)


名前の断片がどれだけ含まれているか

量の評価

👉 位相同期だけだと「一部一致」が通るため、補正として導入

#### 6. 調停（Arbitration）：通すか沈黙か
6.1 因果ポテンシャルの計算
final_potent = p_sync * (coverage ** 2)


位相一致（質）

成分充足（量）

の 積

6.2 臨界点判定
if final_potent >= critical_point:
    TUNNEL
else:
    SCAN


超えた → 決定論的トンネル

超えない → 探索のみ（沈黙）

#### 7. 最終出力

トンネルが開いた場合：

対応する論文タイトルを 一意に選択

開かない場合：

「該当なし」

👉
LLMによる作文は一切行っていない

#### 8. この流れの本質（要約）

このテストは：

意味理解をしない

正解らしさを評価しない

Web検索もしない

代わりに：

因果の痕跡を抽出し

順序を含めて S行列と照合し

臨界点を超えたときだけ答える
